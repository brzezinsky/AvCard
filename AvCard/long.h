//////////////////////////////////////////////////.//
// Notices: Copyright (c)  БГУ, НИИ ППМИ 2010      //
// Автор:   Вячеслав Адамович                      //
/////////////////////////////////////////////////////
#ifndef _LONG_H_
#define _LONG_H_

#include "typedef.h"

//////////////////////////////////////////////////////
// Определение максимального размера большого числа //
//////////////////////////////////////////////////////
//#ifndef MAXLEN
#define MAXLEN  16
//#endif

/////////////////////////////////////////////////////////////////
// Определение констант для 32-разрядных и 16-разрядных чисел  //
/////////////////////////////////////////////////////////////////
#define BITS_LEN       32         // число битов в 32-разрядном слове
#define HALF_BITS_LEN  16         // число битов в 16-разрядном слове

#define MAX_BIT        0x80000000 // старший бит в 32-разрядном слове
#define HALF_MAX_BIT   0x00008000 // старший бит в 16-разрядном слове

#define MAX_LONG       0xFFFFFFFF // максимальное 32-разрядное слово
#define HALF_MAX_LONG  0x0000FFFF // максимальное 16-разрядное слово

///////////////////////////////////////////////
// Выделение разрядов из 32-разрядных чисел  //
///////////////////////////////////////////////

// Выделение 16-и младших разрядов 
#define L_HALF(x) ((x) & HALF_MAX_LONG)

// Выделение старших разрядов и помещение их на место младших
#define H_HALF(x) (((x) >> HALF_BITS_LEN) & HALF_MAX_LONG)

// Выделение младших разрядов и помещение их на место старших
#define LH_HALF(x) (((uint32)(x)) << HALF_BITS_LEN)


/////////////////////////////////
// Определение большого числа  // 
/////////////////////////////////
typedef struct {
	uint32 len;				// размер большого числа в long'ах 
	uint32 arr[MAXLEN + 1];	// массив для размещения большого числа
} LongInt;

///////////////////////////////////////////
// Коды сообщений об ошибках выполнения  // 
///////////////////////////////////////////
#define AE_SUCCESS			((uint32)(0))	// нормальное завершение 
#define	AE_DIVIDE_ZERO		((uint32)(3))	// деление на нуль       
#define AE_MOD_ZERO			((uint32)(4))	// модуль = 0


//////////////////
 

////////////////////////////////////////////////////////////
// Прочитать большое число из буфера в структуру LongInt  //
////////////////////////////////////////////////////////////
EXTERN_C void C_ReadLongInt(
	uint32 bits,			// [ in] размер числа в битах
	void* x,				// [ in] буфер, содержащий число
	LongInt* X				// [out] результирующая структура
);

//////////////////

//Определение числа не значащих нулей переменной типа uint32. 
//Параметры: a - число для определения количества незначащих нулей (a>0).
//Возвращаемое значение:
//         количество незначащих нулей проверяемого числа. 
 
EXTERN_C uint32 ZeroBits (uint32 a); 


/* ************************************************** */
/*                                                    */
/* Арифметика больших чисел без приведения по модулю  */
/*                                                    */
/*  Kорректность параметров не проверяется,           */
/*  это должна делать вызывающая программа.           */
/* ************************************************** */

// Сравнение многоразрядных чисел (А - В) 
// Возвращаемое значение: 
//    1 - если А > B, 
//    0 - если А = B, 
//   -1 - если А < B 

EXTERN_C int32 C_Cmp(LongInt *A, LongInt *B);

//////////////////

// Сдвиг длинного числа влево на К бит: X = X * 2^k  (0 < k < 32). 
// Требуется наличие дополнительного старшего разряда (двойного слова).

EXTERN_C void C_ShL(LongInt *X, uint32 k);

//////////////////

// Сдвиг длинного числа вправо на К бит: X = X div 2^k  (0 < k < 32).

EXTERN_C void C_ShR(LongInt *X, uint32 k);

//////////////////

// Сложение многоразрядных положительных чисел: Y = A + B.
// Допустимо размещение результата на место любого операнда. 

EXTERN_C void C_Add(LongInt *Y, LongInt *A, LongInt *B);

//////////////////

// Получение положительной разности двух многоразрядных
// положительных чисел: Y = A - B (в предположении, что  A > B,
//              эту проверку должна делать вызывающая программа). 
// Допустимо размещение результата на место любого операнда.

EXTERN_C void C_Sub(LongInt *Y, LongInt *A, LongInt *B);

//////////////////

// Деление многоразрядных положительных чисел: Y = A / B, R = A % B.
// Возвращаемое значение:
//	 AE_SUCCESS     - успешное завершение;
//	 AE_DIVIDE_ZERO - деление на нуль (результат не определен).
// Допустимо размещение результата на место делимого и делителя.
// Допустимо обращение:   C_Div(NULL,&A,&A,&B),  в этои случае
// частное не фиксируется, а остаток размещается на месте делимого.

EXTERN_C uint32 C_Div (LongInt *Y, LongInt *R, LongInt *A, LongInt *B);

//////////////////

//  Умножение многоразрядных положительных чисел  Y = A * B;
//
//  Возвращаемое значение:
//	    0  - результат получен,
//	    1  - переполнение,  результат неопределен
//  Допустимо размещение результата на место любого сомножителя
//
EXTERN_C uint32  C_Mult (LongInt *Y, LongInt *A, LongInt *B);

//////////////////


EXTERN_C uint32  C_Div_DWord(LongInt *Y, uint32 *R, LongInt *A, uint32 W);

EXTERN_C void  C_Add_DWord (LongInt *Y, LongInt *A, uint32 W);

EXTERN_C void  C_Sub_DWord (LongInt *Y, LongInt *A, uint32 W);

EXTERN_C void  C_Mult_DWord (LongInt *Y, LongInt *A, uint32 W);


//////////////////

/* ************************************************** */
/*                                                    */
/*  Арифметика больших чисел с приведением по модулю  */
/*                                                    */
/*  Kорректность параметров не проверяется,           */
/*  это должна делать вызывающая программа.           */
/* ************************************************** */

// Сложение многоразрядных положительных чисел по модулю: Y = A + B (mod M).
// Допустимо размещение результата на место любого слагаемого. 

EXTERN_C void C_AddMod (LongInt *Y, LongInt *A, LongInt *B, LongInt *M);

//////////////////

// Вычитание двух многоразрядных положительных чисел по модулю: Y = A - B (mod M).
// Допустимо размещение результата на место любого слагаемого. 

EXTERN_C void C_SubMod (LongInt *Y, LongInt *A, LongInt *B, LongInt *M);

//////////////////

// Умножение многоразрядных положительных чисел по модулю: Y = A * B (mod M)
// Возвращаемое значение:
//	 AE_SUCCESS  - успешное завершение;
//	 AE_MOD_ZERO - модуль равен нулю (результат не определен).
// Допустимо размещение результата на место любого сомножителя.

EXTERN_C uint32 C_MultMod (LongInt *Y, LongInt *A, LongInt *B, LongInt *M);

//////////////////

// Возведение многоразрядного положительного числа в квадрат по модулю:
//                   Y =  X * X  (mod M)
//  Допустимо размещение результата на место сомножителя
EXTERN_C  uint32  C_SqrMod (LongInt *Y, LongInt *X, LongInt *M);

//////////////////

//  Деление многоразрядных положительных чисел
//  по заданному простому модулю   Y = (A div B) mod D
//       (в предположении, что A < D и B < D) 
EXTERN_C uint32  C_DivMod(LongInt *Y, LongInt *A, LongInt *B, LongInt *D);


EXTERN_C uint32  C_DivMod_I(LongInt *Y, LongInt *A, LongInt *B, LongInt *D);

//////////////////


// Возведение многоразрядного положительного числа в "большую" степень
//  по модулю:    Y = (X**P) mod M
EXTERN_C uint32 C_PowerMod(LongInt *Y,	LongInt *X, LongInt *P,	LongInt *M);

//////////////////

// Вычисление обратной величины для заданного большого числа
// по заданному большому простому модулю: inv = a^(-1) (mod p)
// Корректность параметров не проверяется. 
// Значение модуля на простое число не проверяется.

EXTERN_C void C_InverseMod(LongInt *inv, LongInt *a, LongInt *p);

//////////////////

// Вычисление обратной величины для заданного большого числа по
// заданному большому постому модулю  или  наибольшего общего
// делителя двух заданных больших чисел по алгоритму Эвклида.
//
// Взвращаемое значение:
//    0   - Yk - число, обратное к Xk по модулю Fm, (НОД=1),
//    3   - один из операндов равен нулю
//	        ( Xk = 0 или Fm = 0), результат не определен.
//    6   - Yk - наибольший общий делитель чисел Xk и Fm
//          (значение обратной величины неопределено).
//  Замечания:
//    1. Значение модуля на простое число не проверяется.
//    2. Должно выполняться условие:  Xk < Fm.
//    3. Корректность параметров не проверяется.
//
EXTERN_C uint32 F_EUCLID(LongInt *Yk,  // результат вычислений,
						 LongInt *Xk,  // заданное большое число,
						 LongInt *Fm); // заданный большой модуль

//////////////////

//вычисление корня квадратного по простому модулю общего вида
//			  r1  =  sqrt(a) mod p
//
// Корректность параметров не проверяется
// Функция возвращает:
//               0  - успешное завершение,
//               1  - корней нет
// Замечание
//     Второй корень можно вычислить пр правилу:  r2 = p - r1.
EXTERN_C int SqRtMod(LongInt *r1, LongInt *a, LongInt *p);

//////////////////


/* ******************************************************************* */
/*                                                                     */
/* Арифметика больших чисел с приведением по модулю специального вида: */
/*   M = 2^(32n) - K,  где  0 < K < 2^16, n = {8, 12, 16}              */   
/*                                                                     */
/* Корректность передаваемых параметров не проверяется.                */
/* О корректности параметров должна заботиться вызывающая программа.   */
/* ******************************************************************* */

// Умножение многоразрядных положительных чисел по простому модулю:
//                   Y = A * B (mod M).
//   верно только для модуля специального вида: M = 2^(32n) - K ).
// Допустимо размещение результата на место любого сомножителя.
// Корректность параметров не проверяется.

EXTERN_C void C_MultModCrand(LongInt *Y, LongInt *A, LongInt *B, LongInt *M);

//////////////////

// Возведение в квадрат многоразрядного положительного числа 
// по простому модулю: Y = X * X (mod M).
//   верно только для модуля специального вида: M = 2^(32n) - K ).
// Допустимо размещение результата на место сомножителя.
// Корректность параметров не проверяется.

EXTERN_C void C_SqrModCrand(LongInt *Y, LongInt *X, LongInt *M);

//////////////////

// Возведение в степень по простому модулю: Y = X^P (mod M)
//   верно только для модуля специального вида: M = 2^(32n) - K ).
// Допустимо размещение результата на место любого операнда.
// Корректность параметров не проверяется.

EXTERN_C void C_PowerModCrand(LongInt *Y, LongInt *X, LongInt *P, LongInt *M);

//////////////////

//вычисление корня квадратного по простому модулю специального вида
//			r1  =  sqrt(a) mod p
//
//	(модуль вида   p = 2^(32n) - K, (0 < K < 2^16), n = {8,12,16} )
//
// Корректность параметров не проверяется
// Функция возвращает:
//               0  - успешное завершение,
//               1  - корней нет
// Замечание
//     Второй корень можно вычислить пр правилу:  r2 = p - r1.
//
EXTERN_C int SqRtModCrand(LongInt *r1, LongInt *a, LongInt *p);

//////////////////


/* ************************************ */
/*                                      */
/*  Проверка больших чисел на простоту  */
/*                                      */
/* ************************************ */


// Тест проверки "большого" числа  n  на простое ( n > 2^32).
// (Алгоритм Миллера - Рабина.)
// Функция возвращает
//    TRUE  - проверяемое число простое (с большой вероятностью)
//    FALSE - проверяемое число составное
//
EXTERN_C
BOOL  C_TestMR(LongInt *n);     // (X > 2^32)

#endif  
